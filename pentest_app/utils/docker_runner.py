"""
Docker Runner Utilities for Penetration Testing Tools
====================================================

This module provides utilities for running penetration testing tools
in Docker containers for isolation and consistent environments.
"""

import asyncio
import docker
import tempfile
import os
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from loguru import logger

class DockerRunner:
    """
    Utility class for running penetration testing tools in Docker containers.
    
    This provides a secure and isolated environment for running security tools
    while maintaining consistent configurations and dependencies.
    """
    
    def __init__(self):
        """Initialize Docker client."""
        try:
            self.client = docker.from_env()
            self.client.ping()
            logger.info("Docker client initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize Docker client: {e}")
            raise
    
    async def run_nmap(self, target: str, options: List[str] = None) -> Tuple[str, str]:
        """
        Run Nmap scan in a Docker container.
        
        Args:
            target: Target URL or IP address
            options: Additional Nmap command line options
            
        Returns:
            Tuple of (stdout, stderr)
        """
        if not options:
            options = ["-sV", "-sC", "-O", "-A"]
        
        command = ["nmap"] + options + [target]
        
        return await self._run_container(
            image="instrumentisto/nmap:latest",
            command=command,
            network_mode="host"
        )
    
    async def run_nikto(self, target: str, options: List[str] = None) -> Tuple[str, str]:
        """
        Run Nikto web vulnerability scanner in a Docker container.
        
        Args:
            target: Target URL
            options: Additional Nikto command line options
            
        Returns:
            Tuple of (stdout, stderr)
        """
        if not options:
            options = ["-h", target, "-Format", "txt"]
        
        command = ["nikto"] + options
        
        return await self._run_container(
            image="sullo/nikto:latest",
            command=command
        )
    
    async def run_sqlmap(self, target: str, options: List[str] = None) -> Tuple[str, str]:
        """
        Run SQLMap in a Docker container.
        
        Args:
            target: Target URL
            options: Additional SQLMap command line options
            
        Returns:
            Tuple of (stdout, stderr)
        """
        if not options:
            options = ["-u", target, "--batch", "--level=1", "--risk=1"]
        
        command = ["python", "/sqlmap/sqlmap.py"] + options
        
        return await self._run_container(
            image="paoloo/sqlmap:latest",
            command=command
        )
    
    async def run_zap_baseline(self, target: str) -> Tuple[str, str]:
        """
        Run OWASP ZAP baseline scan in a Docker container.
        
        Args:
            target: Target URL
            
        Returns:
            Tuple of (stdout, stderr)
        """
        command = ["zap-baseline.py", "-t", target, "-J", "zap-report.json"]
        
        return await self._run_container(
            image="owasp/zap2docker-stable:latest",
            command=command
        )
    
    async def run_hydra(self, target: str, service: str, 
                       wordlist_path: str = None, 
                       options: List[str] = None) -> Tuple[str, str]:
        """
        Run Hydra password cracking tool in a Docker container.
        
        Args:
            target: Target URL or IP
            service: Service to attack (ssh, http-get, etc.)
            wordlist_path: Path to wordlist file
            options: Additional Hydra options
            
        Returns:
            Tuple of (stdout, stderr)
        """
        if not options:
            options = []
        
        if not wordlist_path:
            # Use default common passwords
            wordlist_path = "/usr/share/wordlists/rockyou.txt"
        
        command = ["hydra", "-L", wordlist_path, "-P", wordlist_path] + options + [target, service]
        
        return await self._run_container(
            image="vanhauser/hydra:latest",
            command=command
        )
    
    async def _run_container(self, 
                           image: str, 
                           command: List[str],
                           network_mode: str = "bridge",
                           timeout: int = 300,
                           volumes: Dict[str, Dict] = None) -> Tuple[str, str]:
        """
        Run a command in a Docker container.
        
        Args:
            image: Docker image to use
            command: Command to execute
            network_mode: Docker network mode
            timeout: Command timeout in seconds
            volumes: Volume mounts
            
        Returns:
            Tuple of (stdout, stderr)
        """
        try:
            logger.info(f"Running command in container: {' '.join(command)}")
            
            # Pull image if not available
            try:
                self.client.images.get(image)
            except docker.errors.ImageNotFound:
                logger.info(f"Pulling Docker image: {image}")
                self.client.images.pull(image)
            
            # Run container
            container = self.client.containers.run(
                image=image,
                command=command,
                network_mode=network_mode,
                volumes=volumes or {},
                detach=True,
                remove=True,
                mem_limit="1g",
                cpu_period=100000,
                cpu_quota=50000,  # Limit to 50% CPU
                security_opt=["no-new-privileges:true"],
                cap_drop=["ALL"],
                cap_add=["NET_RAW", "NET_ADMIN"]  # Required for some network tools
            )
            
            # Wait for completion with timeout
            try:
                result = container.wait(timeout=timeout)
                logs = container.logs(stdout=True, stderr=True).decode('utf-8', errors='ignore')
                
                # Separate stdout and stderr (Docker combines them)
                stdout = logs
                stderr = ""
                
                if result['StatusCode'] != 0:
                    stderr = f"Container exited with code {result['StatusCode']}"
                    logger.warning(f"Container exited with non-zero code: {result['StatusCode']}")
                
                return stdout, stderr
                
            except asyncio.TimeoutError:
                logger.error(f"Container execution timed out after {timeout} seconds")
                container.kill()
                return "", f"Execution timed out after {timeout} seconds"
                
        except Exception as e:
            logger.error(f"Failed to run container: {e}")
            return "", str(e)
    
    def cleanup(self):
        """Clean up Docker resources."""
        try:
            # Remove stopped containers
            self.client.containers.prune()
            
            # Remove unused images (optional, commented out to avoid removing useful images)
            # self.client.images.prune(filters={'dangling': True})
            
            logger.info("Docker cleanup completed")
            
        except Exception as e:
            logger.error(f"Failed to cleanup Docker resources: {e}")

class SecureDockerRunner(DockerRunner):
    """
    Enhanced Docker runner with additional security measures.
    
    This class extends DockerRunner with additional security constraints
    and monitoring capabilities for production use.
    """
    
    def __init__(self, max_concurrent_containers: int = 3):
        """
        Initialize secure Docker runner.
        
        Args:
            max_concurrent_containers: Maximum number of concurrent containers
        """
        super().__init__()
        self.max_concurrent = max_concurrent_containers
        self.active_containers = 0
        self.container_semaphore = asyncio.Semaphore(max_concurrent_containers)
    
    async def _run_container(self, *args, **kwargs) -> Tuple[str, str]:
        """Run container with concurrency limits."""
        async with self.container_semaphore:
            self.active_containers += 1
            try:
                result = await super()._run_container(*args, **kwargs)
                return result
            finally:
                self.active_containers -= 1
    
    def get_resource_usage(self) -> Dict[str, any]:
        """Get current resource usage statistics."""
        try:
            # Get system-wide Docker stats
            containers = self.client.containers.list()
            
            stats = {
                "active_containers": len(containers),
                "pentest_containers": self.active_containers,
                "max_concurrent": self.max_concurrent,
                "available_slots": self.max_concurrent - self.active_containers
            }
            
            return stats
            
        except Exception as e:
            logger.error(f"Failed to get resource usage: {e}")
            return {"error": str(e)}