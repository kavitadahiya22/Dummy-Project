"""
OpenSearch Client for Penetration Testing Results
=================================================

This module provides functionality to store and retrieve penetration testing
results in OpenSearch for analysis and reporting.
"""

import json
import asyncio
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass

from opensearchpy import OpenSearch, AsyncOpenSearch
from opensearchpy.exceptions import OpenSearchException
from loguru import logger

@dataclass
class PentestResult:
    """Data class for standardized pentest results."""
    run_id: str
    timestamp: datetime
    target: str
    tool: str
    finding: str
    severity: str
    details: Optional[Dict] = None
    raw_output: Optional[str] = None

class OpenSearchClient:
    """
    Client for storing and retrieving penetration testing results in OpenSearch.
    
    This client handles:
    - Connection management to the OpenSearch cluster
    - Index creation and management
    - Document storage and retrieval
    - Search and aggregation operations
    """
    
    def __init__(self, 
                 host: str = "cybrty-dev-ca.wonderfuldune-e921120d.eastus.azurecontainerapps.io",
                 port: int = 443,
                 use_ssl: bool = True,
                 verify_certs: bool = False,
                 index_name: str = "pentest-results"):
        """
        Initialize OpenSearch client.
        
        Args:
            host: OpenSearch host
            port: OpenSearch port
            use_ssl: Whether to use SSL
            verify_certs: Whether to verify SSL certificates
            index_name: Name of the index for storing results
        """
        self.host = host
        self.port = port
        self.use_ssl = use_ssl
        self.verify_certs = verify_certs
        self.index_name = index_name
        self.base_path = "/es"
        
        # OpenSearch client configuration
        self.client_config = {
            'hosts': [{'host': host, 'port': port}],
            'http_auth': None,  # Configure if authentication is needed
            'use_ssl': use_ssl,
            'verify_certs': verify_certs,
            'ssl_assert_hostname': False,
            'ssl_show_warn': False,
            'timeout': 30,
            'max_retries': 3,
            'retry_on_timeout': True
        }
        
        # Initialize clients
        self.sync_client = None
        self.async_client = None
        self.is_connected = False
        
        # Index mapping for pentest results
        self.index_mapping = {
            "mappings": {
                "properties": {
                    "run_id": {"type": "keyword"},
                    "timestamp": {"type": "date"},
                    "target": {"type": "keyword"},
                    "tool": {"type": "keyword"},
                    "finding": {"type": "text"},
                    "severity": {"type": "keyword"},
                    "details": {"type": "object", "enabled": True},
                    "raw_output": {"type": "text"},
                    "event_type": {"type": "keyword"},
                    "module": {"type": "keyword"},
                    "status": {"type": "keyword"},
                    "execution_time": {"type": "float"},
                    "error": {"type": "text"},
                    "metadata": {"type": "object", "enabled": True}
                }
            },
            "settings": {
                "number_of_shards": 1,
                "number_of_replicas": 0,
                "refresh_interval": "1s"
            }
        }
    
    async def initialize(self):
        """Initialize the OpenSearch connection and create index if needed."""
        try:
            # Create async client
            self.async_client = AsyncOpenSearch(**self.client_config)
            
            # Test connection
            await self.test_connection()
            
            # Ensure index exists
            await self.ensure_index()
            
            self.is_connected = True
            logger.info("OpenSearch client initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize OpenSearch client: {e}")
            self.is_connected = False
            raise
    
    async def test_connection(self) -> bool:
        """Test the connection to OpenSearch."""
        try:
            if not self.async_client:
                await self.initialize()
            
            # Simple ping to test connection
            response = await self.async_client.info()
            logger.info(f"OpenSearch connection successful: {response['version']['number']}")
            return True
            
        except Exception as e:
            logger.error(f"OpenSearch connection failed: {e}")
            return False
    
    async def ensure_index(self):
        """Ensure the pentest results index exists with proper mapping."""
        try:
            # Check if index exists
            exists = await self.async_client.indices.exists(index=self.index_name)
            
            if not exists:
                # Create index with mapping
                await self.async_client.indices.create(
                    index=self.index_name,
                    body=self.index_mapping
                )
                logger.info(f"Created OpenSearch index: {self.index_name}")
            else:
                logger.info(f"OpenSearch index already exists: {self.index_name}")
                
        except OpenSearchException as e:
            logger.error(f"Failed to create/check index: {e}")
            raise
    
    async def store_result(self, result: PentestResult) -> str:
        """
        Store a penetration testing result in OpenSearch.
        
        Args:
            result: PentestResult object to store
            
        Returns:
            Document ID of the stored result
        """
        try:
            doc = {
                "run_id": result.run_id,
                "timestamp": result.timestamp.isoformat(),
                "target": result.target,
                "tool": result.tool,
                "finding": result.finding,
                "severity": result.severity,
                "details": result.details or {},
                "raw_output": result.raw_output,
                "indexed_at": datetime.utcnow().isoformat()
            }
            
            response = await self.async_client.index(
                index=self.index_name,
                body=doc
            )
            
            logger.info(f"Stored result in OpenSearch: {response['_id']}")
            return response['_id']
            
        except Exception as e:
            logger.error(f"Failed to store result: {e}")
            raise
    
    async def log_event(self, event_data: Dict[str, Any]) -> str:
        """
        Log a generic event to OpenSearch.
        
        Args:
            event_data: Dictionary containing event information
            
        Returns:
            Document ID of the logged event
        """
        try:
            # Add timestamp if not present
            if "timestamp" not in event_data:
                event_data["timestamp"] = datetime.utcnow().isoformat()
            
            response = await self.async_client.index(
                index=self.index_name,
                body=event_data
            )
            
            logger.debug(f"Logged event to OpenSearch: {response['_id']}")
            return response['_id']
            
        except Exception as e:
            logger.error(f"Failed to log event: {e}")
            raise
    
    async def get_results_by_run_id(self, run_id: str) -> List[Dict]:
        """
        Retrieve all results for a specific penetration test run.
        
        Args:
            run_id: Unique identifier for the test run
            
        Returns:
            List of results for the specified run
        """
        try:
            query = {
                "query": {
                    "term": {"run_id": run_id}
                },
                "sort": [{"timestamp": {"order": "asc"}}],
                "size": 1000
            }
            
            response = await self.async_client.search(
                index=self.index_name,
                body=query
            )
            
            results = [hit["_source"] for hit in response["hits"]["hits"]]
            logger.info(f"Retrieved {len(results)} results for run {run_id}")
            
            return results
            
        except Exception as e:
            logger.error(f"Failed to retrieve results for run {run_id}: {e}")
            raise
    
    async def search_vulnerabilities(self, 
                                   target: Optional[str] = None,
                                   severity: Optional[str] = None,
                                   tool: Optional[str] = None,
                                   limit: int = 100) -> List[Dict]:
        """
        Search for vulnerabilities based on criteria.
        
        Args:
            target: Filter by target URL
            severity: Filter by severity level
            tool: Filter by tool used
            limit: Maximum number of results
            
        Returns:
            List of matching vulnerability records
        """
        try:
            query_filters = []
            
            if target:
                query_filters.append({"term": {"target": target}})
            if severity:
                query_filters.append({"term": {"severity": severity}})
            if tool:
                query_filters.append({"term": {"tool": tool}})
            
            # Only include actual findings (not events)
            query_filters.append({"exists": {"field": "finding"}})
            
            query = {
                "query": {
                    "bool": {"must": query_filters}
                } if query_filters else {"match_all": {}},
                "sort": [{"timestamp": {"order": "desc"}}],
                "size": limit
            }
            
            response = await self.async_client.search(
                index=self.index_name,
                body=query
            )
            
            results = [hit["_source"] for hit in response["hits"]["hits"]]
            logger.info(f"Found {len(results)} vulnerabilities matching criteria")
            
            return results
            
        except Exception as e:
            logger.error(f"Failed to search vulnerabilities: {e}")
            raise
    
    async def get_stats(self) -> Dict[str, Any]:
        """
        Get statistics about stored penetration test data.
        
        Returns:
            Dictionary containing various statistics
        """
        try:
            # Total documents
            count_response = await self.async_client.count(index=self.index_name)
            total_docs = count_response["count"]
            
            # Aggregations for statistics
            agg_query = {
                "size": 0,
                "aggs": {
                    "by_severity": {
                        "terms": {"field": "severity", "size": 10}
                    },
                    "by_tool": {
                        "terms": {"field": "tool", "size": 20}
                    },
                    "by_target": {
                        "terms": {"field": "target", "size": 10}
                    },
                    "recent_runs": {
                        "terms": {"field": "run_id", "size": 10}
                    }
                }
            }
            
            agg_response = await self.async_client.search(
                index=self.index_name,
                body=agg_query
            )
            
            stats = {
                "total_documents": total_docs,
                "by_severity": {
                    bucket["key"]: bucket["doc_count"] 
                    for bucket in agg_response["aggregations"]["by_severity"]["buckets"]
                },
                "by_tool": {
                    bucket["key"]: bucket["doc_count"] 
                    for bucket in agg_response["aggregations"]["by_tool"]["buckets"]
                },
                "by_target": {
                    bucket["key"]: bucket["doc_count"] 
                    for bucket in agg_response["aggregations"]["by_target"]["buckets"]
                },
                "recent_runs": [
                    bucket["key"] 
                    for bucket in agg_response["aggregations"]["recent_runs"]["buckets"]
                ]
            }
            
            return stats
            
        except Exception as e:
            logger.error(f"Failed to get statistics: {e}")
            raise
    
    async def close(self):
        """Close the OpenSearch connection."""
        try:
            if self.async_client:
                await self.async_client.close()
                logger.info("OpenSearch connection closed")
        except Exception as e:
            logger.error(f"Error closing OpenSearch connection: {e}")

# Utility functions for creating standardized results
def create_pentest_result(run_id: str, target: str, tool: str, 
                         finding: str, severity: str, 
                         details: Optional[Dict] = None,
                         raw_output: Optional[str] = None) -> PentestResult:
    """Create a standardized PentestResult object."""
    return PentestResult(
        run_id=run_id,
        timestamp=datetime.utcnow(),
        target=target,
        tool=tool,
        finding=finding,
        severity=severity,
        details=details,
        raw_output=raw_output
    )