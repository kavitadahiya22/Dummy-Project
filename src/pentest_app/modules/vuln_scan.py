"""
Vulnerability Scanning Module for Penetration Testing
====================================================

This module handles vulnerability scanning using various tools
like Nikto, OWASP ZAP, and custom vulnerability checks.
"""

import asyncio
import json
from datetime import datetime
from typing import Dict, List, Optional, Any
from urllib.parse import urlparse

import requests
from loguru import logger

from ..utils.opensearch_client import OpenSearchClient, create_pentest_result
from ..utils.docker_runner import DockerRunner

class VulnScanModule:
    """
    Vulnerability scanning module for identifying security weaknesses.
    
    This module performs:
    - Web application vulnerability scanning with Nikto
    - OWASP ZAP baseline scanning
    - Custom vulnerability checks
    - Common web vulnerabilities testing
    """
    
    def __init__(self, run_id: str, target: str, opensearch_client: OpenSearchClient):
        """
        Initialize vulnerability scanning module.
        
        Args:
            run_id: Unique identifier for this test run
            target: Target URL
            opensearch_client: OpenSearch client for logging results
        """
        self.run_id = run_id
        self.target = target
        self.opensearch_client = opensearch_client
        self.docker_runner = DockerRunner()
        
        # Parse target URL
        self.parsed_url = urlparse(target)
        
        # Results storage
        self.results = {
            "module": "vulnerability_scanning",
            "target": target,
            "start_time": datetime.utcnow().isoformat(),
            "findings": [],
            "raw_data": {},
            "status": "initialized"
        }
    
    async def execute(self) -> Dict[str, Any]:
        """
        Execute the complete vulnerability scanning workflow.
        
        Returns:
            Dictionary containing all vulnerability scan results
        """
        try:
            logger.info(f"Starting vulnerability scanning for {self.target}")
            self.results["status"] = "running"
            
            # Nikto Web Scanner
            await self._run_nikto_scan()
            
            # OWASP ZAP Baseline Scan
            await self._run_zap_baseline()
            
            # Custom Vulnerability Checks
            await self._custom_vulnerability_checks()
            
            # SQL Injection Quick Test
            await self._sql_injection_test()
            
            # XSS Detection Test
            await self._xss_detection_test()
            
            # Security Headers Check
            await self._security_headers_check()
            
            # HTTP Methods Testing
            await self._http_methods_test()
            
            self.results["status"] = "completed"
            self.results["end_time"] = datetime.utcnow().isoformat()
            
            # Store summary
            await self._store_summary()
            
            logger.info(f"Vulnerability scanning completed for {self.target}")
            return self.results
            
        except Exception as e:
            logger.error(f"Vulnerability scanning failed for {self.target}: {e}")
            self.results["status"] = "failed"
            self.results["error"] = str(e)
            self.results["end_time"] = datetime.utcnow().isoformat()
            return self.results
    
    async def _run_nikto_scan(self):
        """Run Nikto web vulnerability scanner."""
        try:
            logger.info(f"Running Nikto scan for {self.target}")
            
            # Run Nikto via Docker
            stdout, stderr = await self.docker_runner.run_nikto(
                target=self.target,
                options=["-h", self.target, "-Format", "json", "-Tuning", "1,2,3,4,5,6,7,8,9"]
            )
            
            if stderr:
                logger.warning(f"Nikto stderr: {stderr}")
            
            self.results["raw_data"]["nikto_output"] = stdout
            
            # Parse Nikto output
            nikto_findings = self._parse_nikto_output(stdout)
            
            # Store findings
            for finding in nikto_findings:
                severity = self._determine_severity(finding.get("description", ""))
                
                result = create_pentest_result(
                    run_id=self.run_id,
                    target=self.target,
                    tool="nikto",
                    finding=finding.get("description", "Unknown vulnerability"),
                    severity=severity,
                    details=finding,
                    raw_output=stdout
                )
                await self.opensearch_client.store_result(result)
                
                self.results["findings"].append({
                    "type": "nikto_finding",
                    "description": finding.get("description", ""),
                    "url": finding.get("url", ""),
                    "method": finding.get("method", ""),
                    "severity": severity
                })
                
        except Exception as e:
            logger.error(f"Nikto scan error: {e}")
            self.results["raw_data"]["nikto_error"] = str(e)
    
    async def _run_zap_baseline(self):
        """Run OWASP ZAP baseline scan."""
        try:
            logger.info(f"Running OWASP ZAP baseline scan for {self.target}")
            
            # Run ZAP baseline scan via Docker
            stdout, stderr = await self.docker_runner.run_zap_baseline(self.target)
            
            self.results["raw_data"]["zap_output"] = stdout
            self.results["raw_data"]["zap_stderr"] = stderr
            
            # Parse ZAP output
            zap_findings = self._parse_zap_output(stdout)
            
            # Store findings
            for finding in zap_findings:
                result = create_pentest_result(
                    run_id=self.run_id,
                    target=self.target,
                    tool="owasp_zap",
                    finding=finding.get("name", "Unknown vulnerability"),
                    severity=finding.get("severity", "info"),
                    details=finding,
                    raw_output=stdout
                )
                await self.opensearch_client.store_result(result)
                
                self.results["findings"].append({
                    "type": "zap_finding",
                    "name": finding.get("name", ""),
                    "description": finding.get("description", ""),
                    "url": finding.get("url", ""),
                    "severity": finding.get("severity", "info"),
                    "confidence": finding.get("confidence", "")
                })
                
        except Exception as e:
            logger.error(f"ZAP baseline scan error: {e}")
            self.results["raw_data"]["zap_error"] = str(e)
    
    async def _custom_vulnerability_checks(self):
        """Perform custom vulnerability checks."""
        try:
            logger.info("Running custom vulnerability checks")
            
            # Check for common files/directories
            await self._check_common_files()
            
            # Check for information disclosure
            await self._check_information_disclosure()
            
            # Check for default credentials
            await self._check_default_credentials()
            
        except Exception as e:
            logger.error(f"Custom vulnerability checks error: {e}")
    
    async def _check_common_files(self):
        """Check for common sensitive files."""
        common_files = [
            "robots.txt", "sitemap.xml", ".htaccess", "web.config",
            "phpinfo.php", "info.php", "test.php", "backup.sql",
            ".git/HEAD", ".svn/entries", "WEB-INF/web.xml",
            "crossdomain.xml", "clientaccesspolicy.xml"
        ]
        
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
        
        for file_path in common_files:
            try:
                url = f"{self.target.rstrip('/')}/{file_path}"
                response = requests.get(url, headers=headers, timeout=5, verify=False)
                
                if response.status_code == 200:
                    severity = "medium" if file_path in [".git/HEAD", ".svn/entries", "backup.sql"] else "low"
                    
                    result = create_pentest_result(
                        run_id=self.run_id,
                        target=self.target,
                        tool="file_discovery",
                        finding=f"Sensitive file found: {file_path}",
                        severity=severity,
                        details={"file": file_path, "url": url, "status_code": response.status_code}
                    )
                    await self.opensearch_client.store_result(result)
                    
                    self.results["findings"].append({
                        "type": "sensitive_file",
                        "file": file_path,
                        "url": url,
                        "status_code": response.status_code,
                        "severity": severity
                    })
                    
            except requests.RequestException:
                continue
            
            # Small delay to be respectful
            await asyncio.sleep(0.2)
    
    async def _check_information_disclosure(self):
        """Check for information disclosure vulnerabilities."""
        try:
            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
            
            # Test for server information disclosure
            response = requests.get(self.target, headers=headers, timeout=10, verify=False)
            
            # Check response headers for sensitive information
            sensitive_headers = ["Server", "X-Powered-By", "X-AspNet-Version", "X-AspNetMvc-Version"]
            
            for header in sensitive_headers:
                if header in response.headers:
                    value = response.headers[header]
                    
                    result = create_pentest_result(
                        run_id=self.run_id,
                        target=self.target,
                        tool="information_disclosure",
                        finding=f"Information disclosure in {header} header: {value}",
                        severity="low",
                        details={"header": header, "value": value}
                    )
                    await self.opensearch_client.store_result(result)
                    
                    self.results["findings"].append({
                        "type": "information_disclosure",
                        "header": header,
                        "value": value,
                        "severity": "low"
                    })
            
            # Check for stack traces or error messages
            error_urls = [
                f"{self.target}/nonexistent",
                f"{self.target}/error.php",
                f"{self.target}/500"
            ]
            
            for url in error_urls:
                try:
                    error_response = requests.get(url, headers=headers, timeout=5, verify=False)
                    content = error_response.text.lower()
                    
                    error_indicators = ["stack trace", "exception", "error in", "warning:", "fatal error"]
                    
                    for indicator in error_indicators:
                        if indicator in content:
                            result = create_pentest_result(
                                run_id=self.run_id,
                                target=self.target,
                                tool="error_disclosure",
                                finding=f"Potential error message disclosure at {url}",
                                severity="medium",
                                details={"url": url, "indicator": indicator}
                            )
                            await self.opensearch_client.store_result(result)
                            
                            self.results["findings"].append({
                                "type": "error_disclosure",
                                "url": url,
                                "indicator": indicator,
                                "severity": "medium"
                            })
                            break
                            
                except requests.RequestException:
                    continue
                    
        except Exception as e:
            logger.error(f"Information disclosure check error: {e}")
    
    async def _check_default_credentials(self):
        """Check for common default credentials."""
        # This is a basic check - in production, be more careful about brute force attempts
        common_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", ""),
            ("root", "root"),
            ("test", "test")
        ]
        
        login_paths = ["/login", "/admin", "/administrator", "/wp-admin"]
        
        for path in login_paths:
            try:
                login_url = f"{self.target.rstrip('/')}{path}"
                response = requests.get(login_url, timeout=5, verify=False)
                
                if response.status_code == 200 and "login" in response.text.lower():
                    result = create_pentest_result(
                        run_id=self.run_id,
                        target=self.target,
                        tool="login_discovery",
                        finding=f"Login page found: {login_url}",
                        severity="info",
                        details={"login_url": login_url, "status_code": response.status_code}
                    )
                    await self.opensearch_client.store_result(result)
                    
                    self.results["findings"].append({
                        "type": "login_page",
                        "url": login_url,
                        "severity": "info"
                    })
                    
            except requests.RequestException:
                continue
    
    async def _sql_injection_test(self):
        """Perform basic SQL injection tests."""
        try:
            logger.info("Performing SQL injection tests")
            
            # Basic SQL injection payloads
            sql_payloads = [
                "'", "''", "' OR '1'='1", "' OR '1'='1' --", "'; DROP TABLE users; --"
            ]
            
            # Test common parameters
            test_urls = [
                f"{self.target}?id=1",
                f"{self.target}?user=test",
                f"{self.target}?search=query"
            ]
            
            for base_url in test_urls:
                for payload in sql_payloads:
                    try:
                        # URL encode the payload
                        import urllib.parse
                        encoded_payload = urllib.parse.quote(payload)
                        test_url = base_url.replace("=1", f"={encoded_payload}").replace("=test", f"={encoded_payload}").replace("=query", f"={encoded_payload}")
                        
                        response = requests.get(test_url, timeout=5, verify=False)
                        content = response.text.lower()
                        
                        # Check for SQL error indicators
                        sql_errors = [
                            "sql syntax", "mysql_fetch", "ora-", "postgresql",
                            "sqlite_", "sqlserver", "database error", "syntax error"
                        ]
                        
                        for error in sql_errors:
                            if error in content:
                                result = create_pentest_result(
                                    run_id=self.run_id,
                                    target=self.target,
                                    tool="sql_injection_test",
                                    finding=f"Potential SQL injection vulnerability detected",
                                    severity="high",
                                    details={
                                        "url": test_url,
                                        "payload": payload,
                                        "error_indicator": error
                                    }
                                )
                                await self.opensearch_client.store_result(result)
                                
                                self.results["findings"].append({
                                    "type": "sql_injection",
                                    "url": test_url,
                                    "payload": payload,
                                    "error_indicator": error,
                                    "severity": "high"
                                })
                                break
                                
                    except requests.RequestException:
                        continue
                    
                    # Small delay between requests
                    await asyncio.sleep(0.5)
                    
        except Exception as e:
            logger.error(f"SQL injection test error: {e}")
    
    async def _xss_detection_test(self):
        """Perform basic XSS detection tests."""
        try:
            logger.info("Performing XSS detection tests")
            
            # Basic XSS payloads
            xss_payloads = [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')",
                "<svg onload=alert('XSS')>"
            ]
            
            # Test common parameters
            test_params = ["q", "search", "query", "name", "comment"]
            
            for param in test_params:
                for payload in xss_payloads:
                    try:
                        test_url = f"{self.target}?{param}={payload}"
                        response = requests.get(test_url, timeout=5, verify=False)
                        
                        # Check if payload is reflected in response
                        if payload in response.text:
                            result = create_pentest_result(
                                run_id=self.run_id,
                                target=self.target,
                                tool="xss_detection",
                                finding=f"Potential XSS vulnerability detected",
                                severity="medium",
                                details={
                                    "url": test_url,
                                    "parameter": param,
                                    "payload": payload
                                }
                            )
                            await self.opensearch_client.store_result(result)
                            
                            self.results["findings"].append({
                                "type": "xss_vulnerability",
                                "url": test_url,
                                "parameter": param,
                                "payload": payload,
                                "severity": "medium"
                            })
                            
                    except requests.RequestException:
                        continue
                    
                    # Small delay between requests
                    await asyncio.sleep(0.3)
                    
        except Exception as e:
            logger.error(f"XSS detection test error: {e}")
    
    async def _security_headers_check(self):
        """Check for security headers."""
        try:
            logger.info("Checking security headers")
            
            response = requests.get(self.target, timeout=10, verify=False)
            
            # Required security headers
            security_headers = {
                "X-Frame-Options": "Protects against clickjacking",
                "X-XSS-Protection": "Enables XSS protection",
                "X-Content-Type-Options": "Prevents MIME type sniffing",
                "Strict-Transport-Security": "Enforces HTTPS",
                "Content-Security-Policy": "Prevents XSS and data injection",
                "Referrer-Policy": "Controls referrer information",
                "Feature-Policy": "Controls browser features"
            }
            
            for header, description in security_headers.items():
                if header not in response.headers:
                    result = create_pentest_result(
                        run_id=self.run_id,
                        target=self.target,
                        tool="security_headers",
                        finding=f"Missing security header: {header}",
                        severity="medium",
                        details={"header": header, "description": description}
                    )
                    await self.opensearch_client.store_result(result)
                    
                    self.results["findings"].append({
                        "type": "missing_security_header",
                        "header": header,
                        "description": description,
                        "severity": "medium"
                    })
                    
        except Exception as e:
            logger.error(f"Security headers check error: {e}")
    
    async def _http_methods_test(self):
        """Test for dangerous HTTP methods."""
        try:
            logger.info("Testing HTTP methods")
            
            dangerous_methods = ["PUT", "DELETE", "TRACE", "OPTIONS", "PATCH"]
            
            for method in dangerous_methods:
                try:
                    response = requests.request(method, self.target, timeout=5, verify=False)
                    
                    if response.status_code not in [405, 501]:  # Method not allowed or not implemented
                        result = create_pentest_result(
                            run_id=self.run_id,
                            target=self.target,
                            tool="http_methods",
                            finding=f"Dangerous HTTP method allowed: {method}",
                            severity="medium",
                            details={
                                "method": method,
                                "status_code": response.status_code,
                                "response_length": len(response.content)
                            }
                        )
                        await self.opensearch_client.store_result(result)
                        
                        self.results["findings"].append({
                            "type": "dangerous_http_method",
                            "method": method,
                            "status_code": response.status_code,
                            "severity": "medium"
                        })
                        
                except requests.RequestException:
                    continue
                    
        except Exception as e:
            logger.error(f"HTTP methods test error: {e}")
    
    def _parse_nikto_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse Nikto JSON output."""
        findings = []
        
        try:
            # Try to parse as JSON
            if output.strip().startswith('{'):
                data = json.loads(output)
                
                if 'vulnerabilities' in data:
                    for vuln in data['vulnerabilities']:
                        findings.append({
                            'id': vuln.get('id', ''),
                            'description': vuln.get('msg', ''),
                            'url': vuln.get('uri', ''),
                            'method': vuln.get('method', 'GET'),
                            'osvdb': vuln.get('OSVDB', ''),
                            'refs': vuln.get('refs', [])
                        })
            else:
                # Parse text output
                lines = output.split('\n')
                for line in lines:
                    if '+ OSVDB-' in line or '+ ERROR:' in line or '+ INFO:' in line:
                        findings.append({
                            'description': line.strip(),
                            'url': self.target,
                            'method': 'GET'
                        })
                        
        except json.JSONDecodeError:
            # Fallback to text parsing
            lines = output.split('\n')
            for line in lines:
                if any(keyword in line for keyword in ['OSVDB', 'ERROR', 'INFO', 'WARN']):
                    findings.append({
                        'description': line.strip(),
                        'url': self.target,
                        'method': 'GET'
                    })
        
        return findings
    
    def _parse_zap_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse ZAP output."""
        findings = []
        
        try:
            lines = output.split('\n')
            
            for line in lines:
                if 'WARN' in line or 'HIGH' in line or 'MEDIUM' in line or 'LOW' in line:
                    # Basic parsing of ZAP output
                    parts = line.split('\t') if '\t' in line else line.split()
                    
                    if len(parts) >= 3:
                        findings.append({
                            'name': parts[0] if len(parts) > 0 else 'Unknown',
                            'severity': 'medium',  # Default severity
                            'description': ' '.join(parts[1:]) if len(parts) > 1 else '',
                            'url': self.target,
                            'confidence': 'medium'
                        })
                        
        except Exception as e:
            logger.error(f"Error parsing ZAP output: {e}")
        
        return findings
    
    def _determine_severity(self, description: str) -> str:
        """Determine severity based on description."""
        description_lower = description.lower()
        
        high_indicators = ['injection', 'xss', 'csrf', 'authentication', 'authorization', 'remote code']
        medium_indicators = ['disclosure', 'misconfiguration', 'weak', 'insecure']
        
        for indicator in high_indicators:
            if indicator in description_lower:
                return "high"
                
        for indicator in medium_indicators:
            if indicator in description_lower:
                return "medium"
                
        return "low"
    
    async def _store_summary(self):
        """Store vulnerability scanning summary."""
        try:
            severity_counts = {}
            for finding in self.results["findings"]:
                severity = finding.get("severity", "unknown")
                severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            summary = {
                "total_findings": len(self.results["findings"]),
                "severity_distribution": severity_counts,
                "tools_used": ["nikto", "owasp_zap", "custom_checks"]
            }
            
            result = create_pentest_result(
                run_id=self.run_id,
                target=self.target,
                tool="vulnerability_scan_summary",
                finding=f"Vulnerability scan completed: {summary['total_findings']} findings",
                severity="info",
                details=summary
            )
            await self.opensearch_client.store_result(result)
            
        except Exception as e:
            logger.error(f"Error storing vulnerability scan summary: {e}")