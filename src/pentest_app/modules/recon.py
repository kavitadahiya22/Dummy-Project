"""
Reconnaissance Module for Penetration Testing
============================================

This module handles the reconnaissance phase of penetration testing,
including port scanning, service enumeration, and information gathering.
"""

import asyncio
import json
import socket
import subprocess
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from urllib.parse import urlparse

import nmap
import requests
from loguru import logger

from ..utils.opensearch_client import OpenSearchClient, create_pentest_result
from ..utils.docker_runner import DockerRunner

class ReconModule:
    """
    Reconnaissance module for information gathering and service discovery.
    
    This module performs:
    - Port scanning with Nmap
    - Service version detection
    - DNS enumeration
    - Web technology identification
    - SSL certificate analysis
    """
    
    def __init__(self, run_id: str, target: str, opensearch_client: OpenSearchClient):
        """
        Initialize reconnaissance module.
        
        Args:
            run_id: Unique identifier for this test run
            target: Target URL or IP address
            opensearch_client: OpenSearch client for logging results
        """
        self.run_id = run_id
        self.target = target
        self.opensearch_client = opensearch_client
        self.docker_runner = DockerRunner()
        
        # Parse target URL
        self.parsed_url = urlparse(target)
        self.hostname = self.parsed_url.hostname or target
        self.port = self.parsed_url.port or (443 if self.parsed_url.scheme == 'https' else 80)
        
        # Results storage
        self.results = {
            "module": "reconnaissance",
            "target": target,
            "start_time": datetime.utcnow().isoformat(),
            "findings": [],
            "raw_data": {},
            "status": "initialized"
        }
    
    async def execute(self) -> Dict[str, Any]:
        """
        Execute the complete reconnaissance workflow.
        
        Returns:
            Dictionary containing all reconnaissance results
        """
        try:
            logger.info(f"Starting reconnaissance for {self.target}")
            self.results["status"] = "running"
            
            # DNS Resolution
            await self._dns_resolution()
            
            # Port Scanning
            await self._port_scan()
            
            # Service Detection
            await self._service_detection()
            
            # Web Technology Detection
            await self._web_technology_detection()
            
            # SSL Certificate Analysis
            await self._ssl_analysis()
            
            # Directory Enumeration (lightweight)
            await self._basic_directory_enum()
            
            self.results["status"] = "completed"
            self.results["end_time"] = datetime.utcnow().isoformat()
            
            # Store summary in OpenSearch
            await self._store_summary()
            
            logger.info(f"Reconnaissance completed for {self.target}")
            return self.results
            
        except Exception as e:
            logger.error(f"Reconnaissance failed for {self.target}: {e}")
            self.results["status"] = "failed"
            self.results["error"] = str(e)
            self.results["end_time"] = datetime.utcnow().isoformat()
            return self.results
    
    async def _dns_resolution(self):
        """Perform DNS resolution and reverse DNS lookup."""
        try:
            logger.info(f"Performing DNS resolution for {self.hostname}")
            
            # Forward DNS resolution
            try:
                ip_address = socket.gethostbyname(self.hostname)
                self.results["raw_data"]["ip_address"] = ip_address
                
                # Store finding
                result = create_pentest_result(
                    run_id=self.run_id,
                    target=self.target,
                    tool="dns_resolution",
                    finding=f"IP address resolved: {ip_address}",
                    severity="info",
                    details={"hostname": self.hostname, "ip": ip_address}
                )
                await self.opensearch_client.store_result(result)
                self.results["findings"].append({
                    "type": "dns_resolution",
                    "finding": f"IP address: {ip_address}",
                    "severity": "info"
                })
                
            except socket.gaierror as e:
                logger.warning(f"DNS resolution failed: {e}")
                self.results["raw_data"]["dns_error"] = str(e)
            
            # Reverse DNS lookup
            try:
                if "ip_address" in self.results["raw_data"]:
                    hostname_reverse = socket.gethostbyaddr(self.results["raw_data"]["ip_address"])
                    self.results["raw_data"]["reverse_dns"] = hostname_reverse[0]
                    
                    result = create_pentest_result(
                        run_id=self.run_id,
                        target=self.target,
                        tool="reverse_dns",
                        finding=f"Reverse DNS: {hostname_reverse[0]}",
                        severity="info",
                        details={"ip": self.results["raw_data"]["ip_address"], "hostname": hostname_reverse[0]}
                    )
                    await self.opensearch_client.store_result(result)
                    
            except socket.herror:
                logger.info("No reverse DNS entry found")
                
        except Exception as e:
            logger.error(f"DNS resolution error: {e}")
    
    async def _port_scan(self):
        """Perform port scanning using Nmap."""
        try:
            logger.info(f"Performing port scan for {self.hostname}")
            
            # Use Docker to run Nmap
            stdout, stderr = await self.docker_runner.run_nmap(
                target=self.hostname,
                options=["-sS", "-sV", "-O", "-A", "--top-ports", "1000", "-oX", "-"]
            )
            
            if stderr:
                logger.warning(f"Nmap stderr: {stderr}")
            
            self.results["raw_data"]["nmap_output"] = stdout
            
            # Parse Nmap output (basic parsing - in production, use python-nmap)
            open_ports = self._parse_nmap_output(stdout)
            self.results["raw_data"]["open_ports"] = open_ports
            
            # Store findings
            for port_info in open_ports:
                result = create_pentest_result(
                    run_id=self.run_id,
                    target=self.target,
                    tool="nmap",
                    finding=f"Open port {port_info['port']}/{port_info['protocol']}: {port_info['service']}",
                    severity="info",
                    details=port_info,
                    raw_output=stdout
                )
                await self.opensearch_client.store_result(result)
                
                self.results["findings"].append({
                    "type": "open_port",
                    "port": port_info["port"],
                    "protocol": port_info["protocol"],
                    "service": port_info["service"],
                    "version": port_info.get("version", "unknown"),
                    "severity": "info"
                })
                
        except Exception as e:
            logger.error(f"Port scan error: {e}")
            self.results["raw_data"]["port_scan_error"] = str(e)
    
    async def _service_detection(self):
        """Perform detailed service detection on open ports."""
        try:
            logger.info("Performing service detection")
            
            open_ports = self.results["raw_data"].get("open_ports", [])
            
            for port_info in open_ports:
                port = port_info["port"]
                service = port_info["service"]
                
                # Check for common vulnerable services
                if service.lower() in ["ssh", "telnet", "ftp", "smtp", "pop3", "imap"]:
                    # Banner grabbing
                    banner = await self._grab_banner(self.hostname, port)
                    if banner:
                        port_info["banner"] = banner
                        
                        # Check for version information in banner
                        if any(keyword in banner.lower() for keyword in ["version", "server", "apache", "nginx", "openssh"]):
                            result = create_pentest_result(
                                run_id=self.run_id,
                                target=self.target,
                                tool="banner_grab",
                                finding=f"Service banner on port {port}: {banner[:100]}...",
                                severity="info",
                                details={"port": port, "service": service, "banner": banner}
                            )
                            await self.opensearch_client.store_result(result)
                            
                            self.results["findings"].append({
                                "type": "service_banner",
                                "port": port,
                                "service": service,
                                "banner": banner,
                                "severity": "info"
                            })
                
        except Exception as e:
            logger.error(f"Service detection error: {e}")
    
    async def _web_technology_detection(self):
        """Detect web technologies and frameworks."""
        try:
            logger.info(f"Detecting web technologies for {self.target}")
            
            # Make HTTP request to gather headers and content
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            response = requests.get(self.target, headers=headers, timeout=10, verify=False)
            
            # Store raw response data
            self.results["raw_data"]["http_response"] = {
                "status_code": response.status_code,
                "headers": dict(response.headers),
                "content_length": len(response.content),
                "content_preview": response.text[:500]
            }
            
            # Analyze response headers
            interesting_headers = {}
            security_headers = ["X-Frame-Options", "X-XSS-Protection", "X-Content-Type-Options", 
                              "Strict-Transport-Security", "Content-Security-Policy"]
            
            for header, value in response.headers.items():
                if header.lower() in [h.lower() for h in security_headers]:
                    interesting_headers[header] = value
                elif header.lower() in ["server", "x-powered-by", "x-generator"]:
                    interesting_headers[header] = value
            
            # Check for missing security headers
            for sec_header in security_headers:
                if sec_header not in response.headers:
                    result = create_pentest_result(
                        run_id=self.run_id,
                        target=self.target,
                        tool="header_analysis",
                        finding=f"Missing security header: {sec_header}",
                        severity="medium",
                        details={"missing_header": sec_header, "description": f"Security header {sec_header} not found"}
                    )
                    await self.opensearch_client.store_result(result)
                    
                    self.results["findings"].append({
                        "type": "missing_security_header",
                        "header": sec_header,
                        "severity": "medium",
                        "description": f"Missing {sec_header} security header"
                    })
            
            # Store technology detection results
            if interesting_headers:
                self.results["raw_data"]["interesting_headers"] = interesting_headers
                
                for header, value in interesting_headers.items():
                    result = create_pentest_result(
                        run_id=self.run_id,
                        target=self.target,
                        tool="technology_detection",
                        finding=f"Technology header {header}: {value}",
                        severity="info",
                        details={"header": header, "value": value}
                    )
                    await self.opensearch_client.store_result(result)
                    
                    self.results["findings"].append({
                        "type": "technology_detection",
                        "header": header,
                        "value": value,
                        "severity": "info"
                    })
            
        except Exception as e:
            logger.error(f"Web technology detection error: {e}")
            self.results["raw_data"]["web_tech_error"] = str(e)
    
    async def _ssl_analysis(self):
        """Analyze SSL/TLS configuration."""
        try:
            if self.parsed_url.scheme != "https":
                logger.info("Skipping SSL analysis for non-HTTPS target")
                return
            
            logger.info(f"Analyzing SSL configuration for {self.target}")
            
            # Use openssl command via subprocess for SSL analysis
            try:
                cmd = [
                    "openssl", "s_client", "-connect", f"{self.hostname}:{self.port}",
                    "-servername", self.hostname, "-verify_return_error"
                ]
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdin=asyncio.subprocess.PIPE,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(input=b""),
                    timeout=10
                )
                
                ssl_output = stdout.decode('utf-8', errors='ignore')
                self.results["raw_data"]["ssl_output"] = ssl_output
                
                # Basic SSL analysis
                if "Verify return code: 0 (ok)" in ssl_output:
                    ssl_status = "valid"
                    severity = "info"
                elif "verify error" in ssl_output.lower():
                    ssl_status = "invalid"
                    severity = "medium"
                else:
                    ssl_status = "unknown"
                    severity = "low"
                
                result = create_pentest_result(
                    run_id=self.run_id,
                    target=self.target,
                    tool="ssl_analysis",
                    finding=f"SSL certificate status: {ssl_status}",
                    severity=severity,
                    details={"ssl_status": ssl_status},
                    raw_output=ssl_output
                )
                await self.opensearch_client.store_result(result)
                
                self.results["findings"].append({
                    "type": "ssl_analysis",
                    "ssl_status": ssl_status,
                    "severity": severity
                })
                
            except asyncio.TimeoutError:
                logger.warning("SSL analysis timed out")
            except FileNotFoundError:
                logger.warning("OpenSSL not found, skipping SSL analysis")
                
        except Exception as e:
            logger.error(f"SSL analysis error: {e}")
    
    async def _basic_directory_enum(self):
        """Perform basic directory enumeration."""
        try:
            logger.info(f"Performing basic directory enumeration for {self.target}")
            
            # Common directories to check
            common_dirs = [
                "admin", "administrator", "login", "wp-admin", "cpanel",
                "phpmyadmin", "mysql", "webmail", "mail", "email",
                "user", "users", "account", "accounts", "member", "members",
                "test", "testing", "demo", "dev", "development",
                "backup", "backups", "old", "tmp", "temp"
            ]
            
            found_dirs = []
            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
            
            for directory in common_dirs[:10]:  # Limit to first 10 to avoid being too aggressive
                try:
                    url = f"{self.target.rstrip('/')}/{directory}/"
                    response = requests.get(url, headers=headers, timeout=5, verify=False, allow_redirects=False)
                    
                    if response.status_code in [200, 301, 302]:
                        found_dirs.append({
                            "directory": directory,
                            "status_code": response.status_code,
                            "url": url
                        })
                        
                        result = create_pentest_result(
                            run_id=self.run_id,
                            target=self.target,
                            tool="directory_enum",
                            finding=f"Directory found: /{directory}/ (Status: {response.status_code})",
                            severity="info",
                            details={"directory": directory, "status_code": response.status_code, "url": url}
                        )
                        await self.opensearch_client.store_result(result)
                        
                        self.results["findings"].append({
                            "type": "directory_found",
                            "directory": directory,
                            "status_code": response.status_code,
                            "url": url,
                            "severity": "info"
                        })
                        
                except requests.RequestException:
                    continue  # Skip failed requests
                
                # Small delay to be respectful
                await asyncio.sleep(0.5)
            
            self.results["raw_data"]["found_directories"] = found_dirs
            
        except Exception as e:
            logger.error(f"Directory enumeration error: {e}")
    
    async def _grab_banner(self, hostname: str, port: int, timeout: int = 5) -> Optional[str]:
        """Grab service banner from a specific port."""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(hostname, port),
                timeout=timeout
            )
            
            # Read banner (first few bytes)
            banner_data = await asyncio.wait_for(reader.read(1024), timeout=2)
            banner = banner_data.decode('utf-8', errors='ignore').strip()
            
            writer.close()
            await writer.wait_closed()
            
            return banner if banner else None
            
        except Exception:
            return None
    
    def _parse_nmap_output(self, nmap_output: str) -> List[Dict[str, Any]]:
        """Parse Nmap XML output to extract open ports."""
        open_ports = []
        
        try:
            # This is a simplified parser - in production, use python-nmap or xml parsing
            lines = nmap_output.split('\n')
            
            for line in lines:
                if '/tcp' in line and 'open' in line:
                    parts = line.split()
                    if len(parts) >= 3:
                        port_proto = parts[0]
                        state = parts[1]
                        service = parts[2] if len(parts) > 2 else "unknown"
                        
                        if state == "open":
                            port = port_proto.split('/')[0]
                            protocol = port_proto.split('/')[1] if '/' in port_proto else "tcp"
                            
                            open_ports.append({
                                "port": int(port),
                                "protocol": protocol,
                                "service": service,
                                "state": state
                            })
                            
        except Exception as e:
            logger.error(f"Error parsing Nmap output: {e}")
        
        return open_ports
    
    async def _store_summary(self):
        """Store reconnaissance summary in OpenSearch."""
        try:
            summary = {
                "total_findings": len(self.results["findings"]),
                "open_ports": len([f for f in self.results["findings"] if f["type"] == "open_port"]),
                "missing_security_headers": len([f for f in self.results["findings"] if f["type"] == "missing_security_header"]),
                "directories_found": len([f for f in self.results["findings"] if f["type"] == "directory_found"])
            }
            
            result = create_pentest_result(
                run_id=self.run_id,
                target=self.target,
                tool="reconnaissance_summary",
                finding=f"Reconnaissance completed: {summary['total_findings']} findings",
                severity="info",
                details=summary
            )
            await self.opensearch_client.store_result(result)
            
        except Exception as e:
            logger.error(f"Error storing reconnaissance summary: {e}")